 ex = "2 + 10"
         
      주소1 주소2 주소3  - 스택  
        "2" , "+", "10"      - 힙

    즉 == 와 equals랑 잘 비교해라 차이점
    근데 string은 잘비교해줌 내부에서 equals불러주겟지 오버라이드해서

   ==      -> 변수의 내용을비교 = 동일성비교 
  equals() -> 두 객체의 동질성(내용비교)
                 근데 Object의 equals() 기본구현은 == 연산 결과와 같다.
---------
 java.lang  기본클래스모와둔거?

 Object 클래스 - 최상 
 	          모든객체가 가져야할 기본적인 메소드들정의
	         11개의 메소드가있다. , 기본구현이되어있다.
	         - getClass    -자신의객체정보반환
	         - hashcode  - 비번이런게아니라, 데이터쉽게찾기위한거임
	         - equals  
 	         - toString 
                     - ... 등등

      해싱이뭐냐 - 찾을때? 데이터해쉬돌려서 나오게함 -동일한 값이나올수있다
	            근데 주소기반으로하기때문에 object haschcode는 
                        유일하겠지
----------------
 
 set       = 순서없고 중복안됨
 hashSet = 내용기반으로 중복안되게넣고싶으니까 오버라이드해야지
  
      *오버라이드 안하면 주소기반으로 돌리니 아무리같아도 주소는유일하니 
       그냥 넣어버림  	  
 
 hashSet은 해쉬돌려서 나온값을비교해서 넣으니 훨씬빠르지 int값만비교하니
           근데 해쉬코드 같으면 equals로 마지막비교를해서 다르다고 확신하면
           넣어준다.

  그래서 hashcode랑 equlas랑 같이 오버라이드해야함ㅇㅋ ??
          해쉬가 훨빠르니깐 

   내용비교로오버라이드할떄 equlas보다 해쉬코드를 오버라이드해주는게
  성능상더좋겠지 

-----------------------
  
 String 을 리터럴로 똑같은 문자를 2개만들면
          동일한문자를 가르키게된다. 
 즉 new는 두개가 만들어지는데 이건 하나를가리킴

  즉 상수pool을 이용한다.  처음리터럴로만들면 new로만들어지지만
                                  다음 똑같은걸 만들면 상수풀을보고 
                                  바로 가리키게한다.

     Integer 이것도 인티저pool 쓰겠지
  
 StringBuffer,  
 Synchronized , 락거는거임 , 싱크를맞춘다? 스레드

-------------------------
 wrapper클래스 -이걸써라
   
 short  => Short
 int     => Integer
 long  . .    
 byte 
 char  
 boolean
 float
 double

* EX) Integer i = new Integer(10);  //상수풀이 관여를못함 new로생성하면 
 그리고 인자받을때 객체면 null처리를할수있따.  

* AutoBoxing이 일어날수있도록 리터럴로써라 
